官方例子： 👉 [**球体**](https://threejs.org/examples/?q=panorama#webgl_panorama_equirectangular)  &  [**立方体**](https://threejs.org/examples/?q=panorama#webgl_panorama_cube)

---

该例子采用球体

……略过 基础配置

### 创建带有 全景图的 球体

```js
 	/* 创建合适大小的球体 */
  const geometry = new THREE.SphereGeometry( 500, 60, 40 );
  /* 官方例子使用的 反转球体的 方法*/
 // geometry.scale( - 1, 1, 1 );
  /*导入全景图 */
  const texture = new THREE.TextureLoader().load( './panorama.jpg' );
  //使用SRGB色域显示纹理，会更逼真
  texture.colorSpace = THREE.SRGBColorSpace;
  const material = new THREE.MeshBasicMaterial({
      map: texture,
      side:THREE.BackSide,  // 渲染反面，试了该方法也是可以的，不清楚和上述官方的差异
  })
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
```

这边却别于官方，采用的是控制器移动视角的方法

```js
// 镜头控制器
const controls = new OrbitControls(camera, renderer.domElement);
// 关闭鼠标右键水平 移动
controls.enablePan = false;
// 关闭鼠标缩小放大
controls.enableZoom = false;
//移动控制器到合适的位置
controls.target.set(0, 0, 3);
```

### 如果需要自动旋转的话

```js
controls.autoRotate = true;
controls.autoRotateSpeed = 1;
```

并在`animate` 函数中更新控制器

```js
const clock = new THREE.Clock();
const animate = ()=>{
    requestAnimationFrame(animate);
    controls.update(clock.getDelta())
    renderer.render(scene, camera);
}
```