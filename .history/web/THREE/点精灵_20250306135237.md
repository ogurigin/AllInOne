参考文章： 👉 [**神奇的粒子系统**](https://juejin.cn/post/7155278132806123557)

GUI 文档： 👉 https://github.com/dataarts/dat.gui

---

### 创建点精灵

会根据面板的参数生成。需要对其进行命名，后续可以找到对应的精灵们进行删除，并重新生成。

这边重温下 `cos` 和`sin` 的取值范围

| **COS** | 0 | 90° | 180° | 270° | 360° |
| --- | --- | --- | --- | --- | --- |
|  | 1 | 0 | -1 | 0 | 1 |

| SIN | 0 | 90° | 180° | 270° | 360° |
| --- | --- | --- | --- | --- | --- |
|  | 0 | 1 | 0 | -1 | 0 |

```
//一个随机生成min- max之间随机数的函数
const rand = (min, max) => min + Math.random() * (max - min);
/* 创建点精灵 
panel 为gui操作面板回调的函数*/
const createParticlesByPoints  = (panel)=>{
    const vertices = []; //存储位置信息
    const colorVertices = []; //存储颜色信息
    for ( let i = 0; i < 1000; i ++ ) {
        vertices.push(
            rand(20, 30) * Math.cos(i),
            rand(20, 30) * Math.sin(i),
            rand(-900, 100)
        ); // 算出来大概是一个 螺旋状 的散点
				//会随机生成一个从 0x000000 - panel.color 设定的随机数 
        const randomColor = new THREE.Color(Math.random() * panel.color);
        colorVertices.push(randomColor.r, randomColor.g, randomColor.b);
    }

    const geometry = new THREE.BufferGeometry();
	  //设置 元素的位置信息， 其中3个数值 为一组
    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
    geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorVertices, 3 ) );

    const material = new THREE.PointsMaterial( { 
        size:panel.size,
        transparent: panel.transparent, 
        opacity: panel.opacity,
        color: new THREE.Color(panel.color),
        vertexColors: panel.vertexColors,
        sizeAttenuation: panel.sizeAttenuation,
        map: new THREE.TextureLoader().load('/particle.png')
    } );

    const points = new THREE.Points( geometry, material );
    points.name = 'particles'; //设置 名字，改变样式的时候 可以删除 并重新加载

    scene.add( points );
}
```

### 控制面板

```jsx
/* 控制面板 */
const panel  = new function(){
    this.size = 5;
    this.transparent = true;
    this.opacity = 0.6;
    this.vertexColors = true;
    this.color = 0xffffff;
    this.vertexColor = 0x00ff00;
    this.sizeAttenuation = true;
    this.rotate = true;
    this.redraw = function () {
        if (scene.getObjectByName("particles")) {
            scene.remove(scene.getObjectByName("particles"));
        }
        createParticlesByPoints({
            size: panel.size,
            transparent: panel.transparent,
            opacity: panel.opacity,
            vertexColors: panel.vertexColors,
            sizeAttenuation: panel.sizeAttenuation,
            color: panel.color,
            vertexColor: panel.vertexColor
        });
    };
}
const gui = new GUI();
gui.add(panel, 'size', 0, 10).onChange(panel.redraw);
gui.add(panel, 'transparent').onChange(panel.redraw);
gui.add(panel, 'opacity', 0, 1).onChange(panel.redraw);
gui.add(panel, 'vertexColors', 0, 1).onChange(panel.redraw);
gui.addColor(panel, 'color').onChange(panel.redraw);
gui.addColor(panel, 'vertexColor').onChange(panel.redraw);
gui.add(panel, 'sizeAttenuation').onChange(panel.redraw);
```