参考例子： 👉 [**https://threejs.org/examples/games_fps.html**](https://threejs.org/examples/games_fps.html)

首先创建场景  `new THREE.Scene()`

相机`new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);`，

环境光灯光 `new THREE.AmbientLight('#ffffff', 2)`

点光源 `new THREE.PointLight('#ffffff', 7)`

辅助线： `new THREE.AxesHelper(10);`   必备

**具体细节具体分析**

### 渲染器

```js
const renderer = new THREE.WebGLRenderer({ 
	 antialias: false,//是否执行抗锯齿 默认false
	 alpha: false//是否开启 透明度 
});
renderer.setPixelRatio(window.devicePixelRatio); //设置像素比，以免像素不同造成的模糊
renderer.setSize(window.innerWidth, window.innerHeight); //全屏渲染

renderer.toneMapping = THREE.ACESFilmicToneMapping; //修改渲染器的色调映射模式
// 具体可见 https://threejs.org/docs/index.html#api/en/constants/Renderer
renderer.toneMappingExposure = 1;
//设置了渲染器的色调映射曝光值  HDR 场景中被认为是“中间色调”的亮度。
document.body.appendChild(renderer.domElement); 
```

### 其他一些基础的 变量

```js
const playerVelocity = new THREE.Vector3(); //记录玩家的移动速度
const playerDirection = new THREE.Vector3();//记录玩家的移动方向

const STEPS_PER_FRAME = 5; //检测的频率  每一帧检测的次数

//创建玩家的 胶囊体，前面的两个位置参数 根据需求
const playerCollider = new Capsule( new THREE.Vector3( 18, 1.5, 6 ), new THREE.Vector3(18,2.5, 6 ), 0.5 );
```

### 控制器

试了两种，`FirstPersonControls` **第一人称控制器  和** `PointerLockControls`  **指针锁定控制器**

第一人称：鼠标左右控制视角，可直接点击。自动wasd  移动视角。 鼠标控制方式 不是很习惯。

指针锁定：更像 第一人称游戏的切换模式，但是wasd 控制需要自己输入。

然后在官网找到了合适的例子，

https://threejs.org/examples/games_fps.html

**先说视角控制**：

```js
//需要想把相机的旋转顺序 设为 YXZ
camera.rotation.order = 'YXZ';
//container 为3d加载的容易
/* 这里监听页面按下鼠标，开始锁定光标*/
container.addEventListener( 'mousedown', () => {
     document.body.requestPointerLock();
});
document.body.addEventListener( 'mousemove', ( event ) => {
      if ( document.pointerLockElement === document.body ) {
			//鼠标水平移动的时候 控制模型 沿着y轴旋转  垂直则是 沿着x轴旋转
          camera.rotation.y -= event.movementX / 500;
          camera.rotation.x -= event.movementY / 500;
      }
});
```

试了下代码不难，和使用指针锁定控制器的效果差不多，并可以解放光标，不影响点击事件。 

接下来是 按下 `**WASD` 移动**

```js
const keyStates  = {}; //创建一个对象 用于记录敲下的键
```

两个获取相机 水平前后移动方向的函数

```js
/* 获取 相机的前进或者后退的单位向量 */
const  getForwardVector = ()=>{
    /* 获取相机正视的方向，并赋值给 playerDirection*/
    camera.getWorldDirection( playerDirection );
    /* 垂直方向不动， y置为0*/
    playerDirection.y = 0;
    /* 获取这个方位的 单位向量 */
    playerDirection.normalize();

    return playerDirection;
}
/* 获取 相机的左右的单位向量 */
const getSideVector = ()=>{
    camera.getWorldDirection( playerDirection );
    playerDirection.y = 0;
    playerDirection.normalize();
    playerDirection.cross( camera.up );//叉积  垂直于两个方向

    return playerDirection;
}
```

```js
	/*定义移动速度，获取方向 并乘以速度 */
const controls = (deltaTime) =>{
    const speedDelta = deltaTime * 25; //定义一个速度
    if ( keyStates[ 'KeyW' ] ) {
        playerVelocity.add( getForwardVector().multiplyScalar( speedDelta ) );
    }
    if ( keyStates[ 'KeyS' ] ) {
        playerVelocity.add( getForwardVector().multiplyScalar( -speedDelta ) );
    }
    if ( keyStates[ 'KeyD' ] ) {
        playerVelocity.add( getSideVector().multiplyScalar( speedDelta ) );
    }
    if ( keyStates[ 'KeyA' ] ) {
        playerVelocity.add( getSideVector().multiplyScalar( -speedDelta ) );
    }
}
```

更新玩家位置

```js
const updatePlayer = ( deltaTime ) => {
    /* Math.exp() 方法用于计算自然对数的底数 e 的幂
    该表达式表示 一个随着时间，逐渐减少的值 
    大概是为了 有个缓冲过程，不会一下子变0 */
    let damping = Math.exp( - 4 * deltaTime ) - 1;
    /* 方向向量 + 速度 * 方向向量
    ? 移动的距离？ */ 
    playerVelocity.addScaledVector( playerVelocity, damping );
	
    const deltaPosition = playerVelocity.clone().multiplyScalar( deltaTime );
    playerCollider.translate( deltaPosition );
    playerCollisions(); //防撞测试 
    camera.position.copy( playerCollider.end );
}
```

### 防撞测试

上文中的 `playerCollisions` 方法就是检测碰撞的， 但*不知道为什么，用当前导入的模型无效，而且 `OctreeHelper` 也不显示。*

基础内容

```js
const worldOctree = new Octree(); //创建 八叉树
/*需要的话 可以创建 */
//导入模型 
const loader = new GLTFLoader();
    loader.load('../../../public/testDemo.glb', function (gltf) {
        const model = gltf.scene;
        // 将导入的 场景加入八叉树
        worldOctree.fromGraphNode(model);
				... //省略其他代码
    // 将模型添加到场景中
});
```

**`playerCollisions`** 

```js
const playerCollisions = () =>{
    // 判断  是否存在相交 
    const result = worldOctree.capsuleIntersect(playerCollider);
    if ( result ) {
        // 弹回
        playerCollider.translate( result.normal.multiplyScalar( result.depth ) );
				//有垂直方向的移动的时候 可以用这个 ，本例子暂时不考虑 
        //playerVelocity.addScaledVector( result.normal, - result.normal.dot( playerVelocity ) );
    }
}
```

[第一人称 漫游](https://www.notion.so/95bf8a61aaf745c1824aafaa463ff963?pvs=21)