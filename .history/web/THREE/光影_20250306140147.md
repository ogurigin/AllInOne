参考文章：👉 [**Three.js 进阶之旅：模型光源结合生成明暗变化的创意页面-光与影之诗](https://juejin.cn/post/7148969678642102286)**                  

动画文档：👉 [**TWEEN文档**](https://tweenjs.github.io/tween.js/docs/user_guide_zh-CN.html)

---

其他依旧不赘述

本例子开头使用 TWEEN 来加载loading效果 + 模型移动动画

### 相机组

```jsx
/*创建一个 组，并将相机加入组*/
cameraGroup = new THREE.Group();
scene.add(cameraGroup);
camera = new THREE.PerspectiveCamera(75, topCanvas.clientWidth/topCanvas.clientHeight,0.1, 100);
cameraGroup.add(camera);
```

### 灯光

主要控制点光源 来创建移动的光影

```jsx
// 直射光
const directionLight = new THREE.DirectionalLight(0xffffff, .8);
directionLight.position.set(-100, 0, -80);
scene.add(directionLight);

// 点光源
fillLight = new THREE.PointLight(0x88ffee, 2.7, 4, 3);
fillLight.position.set(2, 3, 1.8);
scene.add(fillLight);
```

### 开头的动画

`html` 写了一个id 为`loadBox` 加载页，提一嘴[**abduction字体**](https://zh.fonts2u.com/abduction.%E5%AD%97%E4%BD%93) 还蛮好看的 

然后采用`LoadingManager` 加载管理器 为导入模型添加动画效果

```js
const manger = new THREE.LoadingManager();
let loadingEle  = document.getElementById('loadBox');
manger.onLoad  = ()=>{
	/* 想下平移出loading 页面*/
    const yPosition = {y:0};
    new TWEEN.Tween(yPosition)
        .to({y:100},1000)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .start()
        .onUpdate(() => { 
            loadingEle.style.setProperty('transform', `translate(0, ${yPosition.y}%)`)}
        )
        .onComplete(function() { //这里使用箭头函数，this读取会有问题
            isLoading.value = false; // 隐藏loading页面，也可以直接删除该元素，这边选择隐藏
            TWEEN.remove(this)
        })
    
    /* 移动相机 动画 
			给一个模型从近到远的 动画*/
    new TWEEN.Tween(camera.position.set(0, 2, 1.2))
        .to({x:0,y:0.6,z:3.3},3500)
        .easing(TWEEN.Easing.Quadratic.InOut)
        .start()
        .onComplete(function (){
						cursor.animateOk = true;
            TWEEN.remove(this)
        })
 }
```

动画 `manger`写好后，需要在加载器重调用，改例子的模型是  **blender** 压缩后的`glb`格式，**windows** 自带的模型管理器可以回报错，但使用`three`js的 `DRACOLoader`加载后会正常显示。

> `vue`使用的时候需要将 `node_modules\three\examples\jsm\libs` 目录下的 `draco`文件夹 复制到`public` 文件夹下面，并按下面的代码配置，才能正常加载。  感觉不是很友好，不确定有没有其他的引入方式。
> 

```jsx
const dracoLoader  = new DRACOLoader();
dracoLoader.setDecoderPath('/draco/');  //配置draco文件夹
dracoLoader.setDecoderConfig({ type: 'js' });
/* 使用加载管理器  添加动画 */
const loader = new GLTFLoader(manger); 
loader.setDRACOLoader(dracoLoader);
```

### 导入模型

```jsx
loader.load('statue.glb', (gltf) => {
    const mesh = gltf.scene;
		const newMaterial = new THREE.MeshPhongMaterial({
	    shininess: 200,
	  });
	 // 遍历模型中的所有对象
    mesh.traverse((obj) => {
        // 如果对象是网格对象
        if (obj.isMesh) {
            // 保存旧材质
            const oldMaterial = obj.material;
            // 创建新的材质 将材质应用到对象上,可以将模型变成反光材质，配合灯光会比较好看
            obj.material = newMaterial;
				     /* 清理旧材质，替换完材质才将模型加入场景，
							真的有需要清理旧的材质 和 清理渲染列表么 */
				    oldMaterial.dispose();
         }
         
    });
		mesh.position.set(0,-1.2,0)
    scene.add(mesh);
    // 清理渲染列表
    renderer.renderLists.dispose();
})
```

👉 问了`ai` 🤣 , 表示在加入场景前替换旧的材质，旧的材质依旧可能会存在在内存中，为了防止内存泄漏，最好的做法是清理。**OKOK 学到了**

### 光影变化

接下来就是 追踪鼠标的移动，并改变相机和 点光源的位置，来实现光影的效果

鼠标跟踪

存储鼠标的位置信息，以及是否移动出该窗口，和自定义的光标元素 `animateOk`为是否完成开头的动画

```jsx
const cursor = reactive( { x: 0, y: 0,hasCursor:true,ele:null,animateOk:false});

```

记得在`init` 方法中 赋值`ele` 

```jsx
cursor.ele = document.querySelector('#cursor');
```

并在在`css`文件中使用`cursor: none;` 隐藏原有鼠标光标
在元素 `#cursor`用 `v-show="cursor.hasCursor"` 操作光标的隐藏显示

```jsx
document.addEventListener('mousemove', (event) => {
    event.preventDefault();
		//移入的时候 显示自定义光标
		if(!cursor.hasCursor) cursor.hasCursor = true;
    cursor.x = event.clientX / window.innerWidth - .5;
    cursor.y = event.clientY / window.innerHeight - .5;
		// 鼠标移动时添加虚拟光标
    cursor.ele.style.cssText = `left: ${event.clientX}px; top: ${event.clientY}px;`;
}, false);
//移出的时候，隐藏自定义光标
document.addEventListener("mouseout", () => {
      cursor.hasCursor = false;
 });
```

在 `animate` 方法中，根据 存储的鼠标位置，进行相机和灯光的移动。

如果不判断  `cursor.hasCursor`  可能会出现 当切换页面很长时间并切回的时候 ，模型出现很小或者很大的情况，但如果过早移出窗口，可能会导致开头的动画卡住， 可以再加载的动画中加个 完成属性，并在`animate`中进行判断 

```jsx
const clock = new THREE.Clock();
const animate = ()=>{
    const deltaTime = clock.getDelta();
    // 点光源位置
		/*如果不判断光标是否移出元素，会出现 切换页面后，再返回 
		发现模型很小或者很大的情况，我这边加了判断 */
    if(cursor.hasCursor || !cursor.animateOk){
        const parallaxY = cursor.y;
        const parallaxX = cursor.x
        fillLight.position.y -= (parallaxY * 9 + fillLight.position.y - 2) *deltaTime;
        fillLight.position.x += (parallaxX * 8 - fillLight.position.x) * 3 *deltaTime;
        // 相机组位置
        cameraGroup.position.z -= (parallaxY  / 3 + cameraGroup.position.z) * deltaTime;
        cameraGroup.position.x += (parallaxX / 3 - cameraGroup.position.x)  * 2 * deltaTime;

        renderer.render( scene, camera );
    }
    TWEEN.update();
    requestAnimationFrame(animate);
}
```